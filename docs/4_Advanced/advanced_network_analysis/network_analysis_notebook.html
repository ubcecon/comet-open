<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-10-05">
<meta name="description" content="This notebook is an introduction to basic network analysis in Python.">

<title>COMET - Networks and NetworkX</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../media/comet_favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="keywords" content="economics, econometrics, R, data, machine learning, UBC, COMET, geog 374, econ 325, econ 326, learning, teaching, learn r, r help, help, tutorial, r tutorial for beginners,learning statistics with r, learn r programming, learn statistics, linear regression, r machine learning, learn machine learning, university of british columbia, british columbia, r programming for beginners, r language tutorial, r tutorial for beginners, economic data, econometrics tutoring, economics help for students, economics homework help, oer resources for teachers, open educational resources for teachers, educational resource, oer project, oer materials, oer resources, learn economics online, learn econometrics, teach yourself economics, teach yourself econometrics, econometrics basics for beginners">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../media/logo_no_tiny_text.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">COMET</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-get-started" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Get Started</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-get-started">    
        <li>
    <a class="dropdown-item" href="../../../pages/quickstart.html" rel="" target="">
 <span class="dropdown-text">Quickstart Guide</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/installation/installing_locally.html" rel="" target="">
 <span class="dropdown-text">Install and Use COMET</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_getting_started.html" rel="" target="">
 <span class="dropdown-text">Get Started</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-learn-by-skill-level" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Learn By Skill Level</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-learn-by-skill-level">    
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_getting_started.html" rel="" target="">
 <span class="dropdown-text">Getting Started</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_beginner.html" rel="" target="">
 <span class="dropdown-text">Beginner</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_intermediate.html" rel="" target="">
 <span class="dropdown-text">Intermediate - Econometrics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_geog.html" rel="" target="">
 <span class="dropdown-text">Intermediate - Geospatial</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_advanced.html" rel="" target="">
 <span class="dropdown-text">Advanced</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="../../../pages/index/all.html" rel="" target="">
 <span class="dropdown-text">Browse All</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-learn-by-class" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Learn By Class</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-learn-by-class">    
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_226.html" rel="" target="">
 <span class="dropdown-text">Making Sense of Economic Data (ECON 226/227)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_325.html" rel="" target="">
 <span class="dropdown-text">Econometrics I (ECON 325)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_326.html" rel="" target="">
 <span class="dropdown-text">Econometrics II (ECON 326)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_geog.html" rel="" target="">
 <span class="dropdown-text">Statistics in Geography (GEOG 374)</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-learn-to-research" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Learn to Research</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-learn-to-research">    
        <li>
    <a class="dropdown-item" href="../../../pages/index/index_research.html" rel="" target="">
 <span class="dropdown-text">Learn How to Do a Project</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teach-with-comet" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Teach With COMET</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teach-with-comet">    
        <li>
    <a class="dropdown-item" href="../../../pages/teaching_with_comet.html" rel="" target="">
 <span class="dropdown-text">Learn how to teach with Jupyter and COMET</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/using_comet.html" rel="" target="">
 <span class="dropdown-text">Using COMET in the Classroom</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/dissemination/dissemination.html" rel="" target="">
 <span class="dropdown-text">See COMET presentations</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-contribute" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Contribute</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-contribute">    
        <li>
    <a class="dropdown-item" href="../../../pages/installation/installing_for_development.html" rel="" target="">
 <span class="dropdown-text">Install for Development</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/documentation/writing_self_tests.html" rel="" target="">
 <span class="dropdown-text">Write Self Tests</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-launch-comet" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
      <i class="bi bi-play" role="img">
</i> 
 <span class="menu-text">Launch COMET</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-launch-comet">    
        <li>
    <a class="dropdown-item" href="https://open.jupyter.ubc.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-notebooks&amp;urlpath=lab%2Ftree%2Fcomet-notebooks%2F&amp;branch=main" rel="" target=""><i class="bi bi-cloud-check" role="img">
</i> 
 <span class="dropdown-text">Launch on JupyterOpen (with Data)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://open.jupyter.ubc.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-project&amp;urlpath=lab%2Ftree%2Fcomet-project%2F&amp;branch=main" rel="" target=""><i class="bi bi-cloud-check" role="img">
</i> 
 <span class="dropdown-text">Launch on JupyterOpen (lite)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://ubc.syzygy.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-project&amp;urlpath=lab%2Ftree%2Fcomet-project%2F&amp;branch=main" rel="" target=""><i class="bi bi-gear" role="img">
</i> 
 <span class="dropdown-text">Launch on Syzygy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://colab.research.google.com/github/ubcecon/comet-notebooks/blob/main/" rel="" target=""><i class="bi bi-google" role="img">
</i> 
 <span class="dropdown-text">Launch on Colab</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-notebooks/archive/refs/heads/main.zip" rel="" target=""><i class="bi bi-cloud-download" role="img">
</i> 
 <span class="dropdown-text">Launch Locally</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-open/archive/refs/heads/datasets.zip" rel="" target=""><i class="bi bi-clipboard-data" role="img">
</i> 
 <span class="dropdown-text">Project Datasets</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-open" rel="" target="">
 <span class="dropdown-text">Github Repository</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../#" rel="" target="">
 <span class="menu-text">|</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../../pages/team.html" rel="" target="">
 <span class="dropdown-text">COMET Team</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/copyright.html" rel="" target="">
 <span class="dropdown-text">Copyright Information</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link active" data-scroll-target="#prerequisites">0. Prerequisites</a></li>
  <li><a href="#what-is-network-analysis" id="toc-what-is-network-analysis" class="nav-link" data-scroll-target="#what-is-network-analysis">1. What is Network analysis?</a>
  <ul class="collapse">
  <li><a href="#key-terms" id="toc-key-terms" class="nav-link" data-scroll-target="#key-terms">1.1 Key terms</a></li>
  <li><a href="#networkx" id="toc-networkx" class="nav-link" data-scroll-target="#networkx">1.2 NetworkX</a></li>
  <li><a href="#creating-random-graphs" id="toc-creating-random-graphs" class="nav-link" data-scroll-target="#creating-random-graphs">1.3 Creating Random Graphs</a></li>
  </ul></li>
  <li><a href="#degrees-density-and-weights" id="toc-degrees-density-and-weights" class="nav-link" data-scroll-target="#degrees-density-and-weights">2. Degrees, Density and Weights</a>
  <ul class="collapse">
  <li><a href="#degrees" id="toc-degrees" class="nav-link" data-scroll-target="#degrees">2.1 Degrees</a></li>
  <li><a href="#density" id="toc-density" class="nav-link" data-scroll-target="#density">2.2 Density</a></li>
  <li><a href="#weights" id="toc-weights" class="nav-link" data-scroll-target="#weights">2.3 Weights</a></li>
  <li><a href="#adjacency-matrices" id="toc-adjacency-matrices" class="nav-link" data-scroll-target="#adjacency-matrices">3. Adjacency matrices</a></li>
  </ul></li>
  <li><a href="#working-with-archeological-datasets" id="toc-working-with-archeological-datasets" class="nav-link" data-scroll-target="#working-with-archeological-datasets">4. Working with archeological datasets</a>
  <ul class="collapse">
  <li><a href="#importing-datasets-in-python" id="toc-importing-datasets-in-python" class="nav-link" data-scroll-target="#importing-datasets-in-python">4.1 Importing datasets in Python</a></li>
  <li><a href="#adding-a-geospacial-component-to-our-graph" id="toc-adding-a-geospacial-component-to-our-graph" class="nav-link" data-scroll-target="#adding-a-geospacial-component-to-our-graph">4.2 Adding a geospacial component to our graph</a></li>
  <li><a href="#working-with-weighed-graphs" id="toc-working-with-weighed-graphs" class="nav-link" data-scroll-target="#working-with-weighed-graphs">4.3 Working with weighed graphs</a></li>
  </ul></li>
  <li><a href="#measures-of-centrality" id="toc-measures-of-centrality" class="nav-link" data-scroll-target="#measures-of-centrality">5. Measures of Centrality</a>
  <ul class="collapse">
  <li><a href="#network-distance-and-eccentricity" id="toc-network-distance-and-eccentricity" class="nav-link" data-scroll-target="#network-distance-and-eccentricity">5.1 Network Distance and Eccentricity</a></li>
  <li><a href="#degree-centrality" id="toc-degree-centrality" class="nav-link" data-scroll-target="#degree-centrality">5.2 Degree Centrality</a></li>
  <li><a href="#closeness-centrality" id="toc-closeness-centrality" class="nav-link" data-scroll-target="#closeness-centrality">5.3 Closeness Centrality</a></li>
  <li><a href="#betweenness-centrality" id="toc-betweenness-centrality" class="nav-link" data-scroll-target="#betweenness-centrality">5.4 Betweenness Centrality</a></li>
  <li><a href="#eigenvector-centrality" id="toc-eigenvector-centrality" class="nav-link" data-scroll-target="#eigenvector-centrality">5.5 Eigenvector centrality</a></li>
  <li><a href="#directed-graphs-and-putting-it-all-together" id="toc-directed-graphs-and-putting-it-all-together" class="nav-link" data-scroll-target="#directed-graphs-and-putting-it-all-together">5.6 Directed graphs and Putting it all together</a></li>
  </ul></li>
  <li><a href="#group-level-analysis-finding-subgroups-within-networks" id="toc-group-level-analysis-finding-subgroups-within-networks" class="nav-link" data-scroll-target="#group-level-analysis-finding-subgroups-within-networks">6. Group-level analysis: finding subgroups within networks</a></li>
  <li><a href="#network-level-analysis-clusters-and-clustering-coefficients" id="toc-network-level-analysis-clusters-and-clustering-coefficients" class="nav-link" data-scroll-target="#network-level-analysis-clusters-and-clustering-coefficients">7. Network-level analysis: Clusters and clustering coefficients</a>
  <ul class="collapse">
  <li><a href="#louvain-algorithm" id="toc-louvain-algorithm" class="nav-link" data-scroll-target="#louvain-algorithm">7.1 Louvain Algorithm</a></li>
  <li><a href="#clustering-coefficients" id="toc-clustering-coefficients" class="nav-link" data-scroll-target="#clustering-coefficients">7.2 Clustering coefficients</a></li>
  </ul></li>
  <li><a href="#citations" id="toc-citations" class="nav-link" data-scroll-target="#citations">8. Citations</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/ubcecon/comet-open/issues/new" class="toc-action">Report an issue</a></p></div></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="network_analysis_notebook.ipynb" download="network_analysis_notebook.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Networks and NetworkX</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">network analysis</div>
  </div>
  </div>

<div>
  <div class="description">
    This notebook is an introduction to basic network analysis in Python.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">5 October 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>This notebook introduces key concepts in network analysis pertaining to archeology and provides a hands-on tutorial to using the NetworkX Python library.</p>
<section id="prerequisites" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites">0. Prerequisites</h2>
<ul>
<li>Read through and follow the instructions in the pre-reading.
<ul>
<li>Have Python and Jupyter set up on your device.</li>
<li>Have created the <code>networks</code> environment.</li>
</ul></li>
<li>If you have not done this, see the pre-reading.</li>
</ul>
</section>
<section id="what-is-network-analysis" class="level2">
<h2 class="anchored" data-anchor-id="what-is-network-analysis">1. What is Network analysis?</h2>
<p><strong>Network Analysis</strong> is a set of techniques used to study the structure and dynamics of networks. <strong>Networks</strong> are collections of objects/locations/entities (called <em>nodes</em>) connected by relationships (called <em>edges</em>). Network analysis has applications in many fields, including sociology, biology, economics, computer science, and more.</p>
<figure class="figure">
<img src="media/networks.png" alt="Network" style="width:80%" class="figure-img">
<figcaption class="figure-caption">
Regional networks of ceramic similarity across time in the greater Arizona/New Mexico area of the US (From Mills et al.&nbsp;2013, Fig. 2)
</figcaption>
</figure>
<p><strong>Network science in archeology</strong> is traditional network science used in an archeological context. According to Brighmans and Peeples (2023), archeological network science falls within the discipline of archeology and is not a discipline of its own: “[N]etwork science applied to archaeological research is a subset of archaeological research: it does not happen in isolation, it is not immune to the limitations of archaeological data nor does it replace archaeological theory.”</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/abstraction_of_NA_research_process.png" class="img-fluid figure-img" style="width:80.0%" alt="Archeological network science research process"></p>
<figcaption class="figure-caption">Archeological network research process. (Brighmans and Peeples, 2023)</figcaption>
</figure>
</div>
<section id="key-terms" class="level3">
<h3 class="anchored" data-anchor-id="key-terms">1.1 Key terms</h3>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/example_graph.png" style="width:100.0%" alt="Nodes in a network." height="300" class="figure-img"></p>
<figcaption class="figure-caption">An example of a graph with nodes and edges.</figcaption>
</figure>
</div>
</div><div class="column" style="width:50%;">
<p><strong>Node:</strong> A node is a representation of an individual entity or actor in a network. In different contexts, nodes can be people, organizations, cities, or any other unit of analysis.</p>
<p><strong>Edge:</strong> An edge represents the relationship or connection between two nodes. Edges can be directed (having a specific direction from one node to another) or undirected (no direction, implying a mutual relationship).</p>
</div>
</div>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/example_graph_2.png" style="width:100.0%" alt="Nodes in a network with degree." height="300" class="figure-img"></p>
<figcaption class="figure-caption">An example of a network with nodes colored by degree.</figcaption>
</figure>
</div>
</div><div class="column" style="width:50%;">
<p><strong>Degree:</strong> The degree of a node is the number of edges connected to it. In directed networks, this can be further divided into in-degree (number of incoming edges) and out-degree (number of outgoing edges).</p>
</div>
</div>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/example_graph_dir.png" style="width:100.0%" alt="Nodes in a network with degree." height="300" class="figure-img"></p>
<figcaption class="figure-caption">An example of a network with nodes colored by degree.</figcaption>
</figure>
</div>
</div><div class="column" style="width:50%;">
<p>The network above is an example of a <strong>Undirected graph</strong>, a graph with no direction. This means that if there is a connection between node A and node B, it is bidirectional - A is connected to B, and B is connected to A.</p>
<p>The example to the left is a <strong>directed graph</strong>: the edges between nodes have a specific direction. This means that if there is an edge from node A to node B, it does not imply there is an edge from B to A unless explicitly stated.</p>
</div>
</div>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/example_density.png" style="width:100.0%" alt="Nodes in a network with degree." height="300" class="figure-img"></p>
<figcaption class="figure-caption">An example of a network with nodes colored by degree.</figcaption>
</figure>
</div>
</div><div class="column" style="width:50%;">
<p><strong>Density:</strong> Density is a measure that indicates how closely connected the nodes in a network are. Specifically, it refers to the ratio of the number of actual edges in the network to the maximum possible number of edges between nodes.</p>
</div>
</div>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/example_graph_closeness_centrality.png" style="width:100.0%" alt="Nodes in a network with degree." height="300" class="figure-img"></p>
<figcaption class="figure-caption">An example of a network with nodes colored by degree.</figcaption>
</figure>
</div>
</div><div class="column" style="width:50%;">
<p><strong>Centrality:</strong> Centrality measures the importance, influence, or prominence of nodes (entities) within a network. The centrality of a node tells us how “important” a node is to the aggregate network. There are many different kinds of centrality, but the four most well-known ones are degree, betweenness, closeness, and eigenvector centrality. This notebook will primarily focus on the first three.</p>
</div>
</div>
</section>
<section id="networkx" class="level3">
<h3 class="anchored" data-anchor-id="networkx">1.2 NetworkX</h3>
<p><code>NetworkX</code> is a Python library that is used for the creation, manipulation, and visualization of complex networks. It provides tools to work with both undirected and directed networks, perform network-related calculations, and visualize the results.</p>
<p>A library in Python is a collection of code that makes everyday tasks more efficient. In this case working with networks becomes much simpler when using network X.</p>
<p>If you want to read the NetworkX documentation you can follow the <a href="https://networkx.org/documentation/stable/reference/introduction.html" target="_blank">NetworkX documentation link</a>. This link shows what kind of commands exist within the NetworkX library.</p>
<section id="importing-networkx" class="level4">
<h4 class="anchored" data-anchor-id="importing-networkx">1.2.1 Importing NetworkX</h4>
<p>We can import NetworkX using the <code>import</code> command. At the same time, we’ll also import the <code>matplotlib.pyplot</code> library, for plotting graphs. Additionally, we’ll import <code>pandas</code> for basic data wrangling, and <code>numpy</code> for math. The <code>as</code> command allows us to use <code>networkx</code> commands without needing to type out <code>networkx</code> each time. Additionally, we’ll import the <code>community_louvain</code> package for the <em>louvain</em> clustering algorithm. Along with some other libraries for our code to function.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt <span class="co">#allows us to call the matplotlib.pyplot library as 'plt'</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.patches <span class="im">as</span> mpatches <span class="co">#imports mpatches matplotlib subpackage </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx <span class="co">#allows us to call the networkx library as 'nx'</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd <span class="co">#allows us to call the pandas library as 'pd'</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> contextily <span class="im">as</span> ctx</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1.inset_locator <span class="im">import</span> inset_axes</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> community <span class="im">as</span> community_louvain</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Let's us open the datasets in Google Collab easily</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>os.system(<span class="st">"wget https://github.com/ubcecon/ai-workshop/blob/ccss-networks.zip"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>os.system(<span class="st">"ccss-networks"</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>csv_path <span class="op">=</span> (<span class="st">"https://github.com/ubcecon/ai-workshop/blob/ccss-networks/data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="creating-simple-networks-using-networkx" class="level4">
<h4 class="anchored" data-anchor-id="creating-simple-networks-using-networkx">1.2.2 Creating simple networks using NetworkX</h4>
<p>We’ll start by creating a simple graph:</p>
<p>Below in the code we choose our nodes and edges between them.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.Graph() <span class="co">#creates an empty network graph</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>) <span class="co">#our nodes, labeled 1,2,3,4,5,6.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">5</span>), (<span class="dv">3</span>,<span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">6</span>), (<span class="dv">6</span>, <span class="dv">1</span>), (<span class="dv">6</span>, <span class="dv">3</span>), (<span class="dv">6</span>,<span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">3</span>), (<span class="dv">5</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">5</span>)]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">#the connections between our nodes are stored in an array, containing pairs of numbers called tuples.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(edges) <span class="co">#the `add_edges_from()` command adds edges to the network</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>G.add_nodes_from(nodes) <span class="co">#the `add_nodes_from()` command adds nodes to the network</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>nx.draw(G, with_labels <span class="op">=</span> <span class="va">True</span>) <span class="co">#renders the graph in the notebook</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">#the `with_labels = True` argument specifies that we want labels on the nodes.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s create a directed graph using <code>nx.DiGraph()</code>. We’ll also set our node positions using a seed: this will ensure that each time the nodes are rendered they hold the same position on the graph. You can set the seed to any number.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.DiGraph() <span class="co">#creates an empty directed graph object</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>) <span class="co">#our nodes</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">5</span>), (<span class="dv">3</span>,<span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">6</span>), (<span class="dv">6</span>, <span class="dv">1</span>), (<span class="dv">6</span>, <span class="dv">3</span>), (<span class="dv">6</span>,<span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">3</span>), (<span class="dv">5</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">5</span>)] <span class="co">#our tuples stored in an array which represent our nodes</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(edges) <span class="co">#connects edges to nodes</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>G.add_nodes_from(nodes) <span class="co">#connects edges to nodes</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> nx.spring_layout(G, seed<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">#nx.draw plots our network</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>nx.draw(G, pos <span class="op">=</span> position, with_labels <span class="op">=</span> <span class="va">True</span>) <span class="co"># `pos` argument assigns a position to each node</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="creating-random-graphs" class="level3">
<h3 class="anchored" data-anchor-id="creating-random-graphs">1.3 Creating Random Graphs</h3>
<p>Instead of creating a graph with predetermined positions of nodes and edges we can also generate a random graph with a set amount of nodes and edges. Below you can change the amount of nodes and edges by changing <code>n</code> and <code>d</code> which correspond to the number of nodes and the degree (number of edges) that each node has. Creating a random graph could be more helpful for testing or when you want to try something and don’t wish to spend time plotting a real network and determining paths for all edges and nodes.</p>
<p>The first most basic command we will use is the <code>nx.random_regular_graph</code> command. Which generates a random regular graph.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a seed for reproducibility so that everytime the code runs we get the same random graph</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">42</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">20</span>  <span class="co"># number of nodes</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">3</span>   <span class="co"># degree of each node</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the random regular graph</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>rr_graph <span class="op">=</span> nx.random_regular_graph(d, n)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the graph, you can change the size, color, font and node size. </span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>)) </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>nx.draw(rr_graph, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">'lightgreen'</span>, node_size<span class="op">=</span><span class="dv">500</span>, font_size<span class="op">=</span><span class="dv">10</span>, font_weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Random Regular Graph"</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Print some basic information about the graph</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of nodes: </span><span class="sc">{</span>rr_graph<span class="sc">.</span>number_of_nodes()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of edges: </span><span class="sc">{</span>rr_graph<span class="sc">.</span>number_of_edges()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Degree of each node: </span><span class="sc">{</span>d<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Another option is using the Erdős-Rényi model which can be accessed using the <code>nx.erdos_renyi_graph(n, p)</code> command. This command has two inputs n and p.&nbsp;N is the number of nodes and p is the probability of edge creation to each node.</p>
<p>The Erdős–Rényi model refers to one of two closely related models for generating random graphs or the evolution of a random network. These models are named after Hungarian mathematicians Paul Erdős and Alfréd Rényi, who introduced one of the models in 1959</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a seed for reproducibility so that everytime the code runs we get the same random graph</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">43</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">20</span>  <span class="co"># number of nodes</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fl">0.2</span>  <span class="co"># probability of edge creation</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the Erdős-Rényi random graph</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>er_graph <span class="op">=</span> nx.erdos_renyi_graph(n, p)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the graph</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>nx.draw(er_graph, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">'lightblue'</span>, node_size<span class="op">=</span><span class="dv">500</span>, font_size<span class="op">=</span><span class="dv">10</span>, font_weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Erdős-Rényi Random Graph"</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Print some basic information about the graph</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of nodes: </span><span class="sc">{</span>er_graph<span class="sc">.</span>number_of_nodes()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of edges: </span><span class="sc">{</span>er_graph<span class="sc">.</span>number_of_edges()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average degree: </span><span class="sc">{</span><span class="bu">sum</span>(<span class="bu">dict</span>(er_graph.degree()).values()) <span class="op">/</span> n<span class="sc">:.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are more commands in NetworkX to generate random graphs, but the two above demonstrate two common methods of random graph generations. The first being a set number of nodes and edges and the second being a set number of nodes and a probability of edge creation between them.</p>
</section>
</section>
<section id="degrees-density-and-weights" class="level2">
<h2 class="anchored" data-anchor-id="degrees-density-and-weights">2. Degrees, Density and Weights</h2>
<section id="degrees" class="level3">
<h3 class="anchored" data-anchor-id="degrees">2.1 Degrees</h3>
<p>The <strong>degree</strong> of a node is the number of edges that are connected to a node. The degree of a node <span class="math inline">\(N\)</span> is denoted as <span class="math inline">\(deg(N)\)</span>. The maximum degree of a network <span class="math inline">\(G\)</span> is denoted by <span class="math inline">\(\Delta(G)\)</span> and is the degree of the node with the highest degree in the network. Conversely, the minimum degree is denoted as <span class="math inline">\(\delta(G)\)</span>.</p>
<ul>
<li>If a node on a graph with <span class="math inline">\(n\)</span> nodes has degree <span class="math inline">\(n-1\)</span> it is called a <em>dominating vertex</em>. Not every graph has a dominating vertex.</li>
</ul>
<p>We can see the degree of each node by running <code>dict(G.degree())</code>. This create a dictionary of key-value pairs for our network, where each key is the name of the node and the value is it’s respective degree.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> <span class="bu">dict</span>(G.degree())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we want to see the degree of node <span class="math inline">\(n\)</span>, we can do so by running <code>print(degrees[n])</code>. For instance:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(degrees[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s color the nodes of our graph based on their degree. We’ll create a function called <code>get_node_colors</code> which takes in the degree dictionary of each node and returns a color. We’ll then create a for-loop that iterates over each nodes in the list of nodes, gets the color of each node using the <code>get_node_colors</code> function we defined earlier, and appends it to an empty list called <code>color_map</code>.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> <span class="bu">dict</span>(G.degree())</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> <span class="bu">list</span>(G.nodes())</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_node_colors(degree):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>]:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'blue'</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> degree <span class="kw">in</span> [<span class="dv">3</span>, <span class="dv">4</span>]:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'green'</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> degree <span class="kw">in</span> [<span class="dv">5</span>, <span class="dv">6</span>]:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'yellow'</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'red'</span> </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>color_map <span class="op">=</span> [] <span class="co">#`color_map` is an empty list</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  color <span class="op">=</span> get_node_colors(degrees[node]) <span class="co"># get color of current node using node_colors according to degree of node</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  color_map.append(color) <span class="co"># appends color of each node to color_map for each node in nodes</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(degrees)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(nodes)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(color_map)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <span class="math inline">\(n\)</span>-th entry in <code>color_map</code> corresponds to the <span class="math inline">\(n\)</span>-th node in <code>nodes</code>. For instance, <code>color_map[0]</code> returns the color of the first node (1).</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>color_map[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now color the nodes of our graph, using the color map we defined above. The <code>node_color</code> argument takes in an array or list of colors that it uses to color each node.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.DiGraph() <span class="co"># creates an empty directed graph object</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>) </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">5</span>), (<span class="dv">3</span>,<span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">6</span>), (<span class="dv">6</span>, <span class="dv">1</span>), (<span class="dv">6</span>, <span class="dv">3</span>), (<span class="dv">6</span>,<span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">3</span>), (<span class="dv">5</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">5</span>)]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(edges) </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>G.add_nodes_from(nodes) </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> nx.spring_layout(G, seed<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>nx.draw(G, pos <span class="op">=</span> position, node_color<span class="op">=</span>color_map, with_labels<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># node_color argument colors the nodes based on a given list or array of colors, </span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with the first color corresponding to the first node, second to the second node, etc.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s also add a legend to our graph, which gives information about the meaning of each color. We’ll do this using the <code>mpatches</code> subpackage we imported earlier.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>blue_patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'1-2 edges'</span>) </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>green_patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'3-4 edges'</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>yellow_patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'yellow'</span>, label<span class="op">=</span><span class="st">'5-6 edges'</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[blue_patch, green_patch, yellow_patch]) <span class="co">#adds legend to the plot</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>nx.draw(G, pos <span class="op">=</span> position, node_color<span class="op">=</span>color_map, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="density" class="level3">
<h3 class="anchored" data-anchor-id="density">2.2 Density</h3>
<p>Density is defined as:</p>
<p><span class="math display">\[
\text{Density} = \frac{\text{Number of Possible Edges}}{\text{Number of Actual Edges}}
​\]</span></p>
<p>In an undirected graph, the total number of edges is <span class="math inline">\(\frac{V\times(V-1)}{2}\)</span>, where V is the total number of nodes. In a directed graph, the total number of edges is <span class="math inline">\(V\times(V-1)\)</span>, because a connection between point A and point B can either be <em>from</em> point A <em>to</em> point B, or <em>to</em> point A <em>from</em> point B (hence multiplying by 2).</p>
<ul>
<li>Note that self-loops (edges from and to the same node) are counted in the total number of edges but not in the maximum number of edges so graphs can have a density greater than 1.</li>
</ul>
<p>The formula for undirected graph density is:</p>
<p><span class="math display">\[
\frac{2E}{V(V-1)}
\]</span></p>
<p>And for directed graphs, it is:</p>
<p><span class="math display">\[
\frac{E}{V(V-1)}
\]</span></p>
<p>Where <span class="math inline">\(E\)</span> is the number of edges in our graph and <span class="math inline">\(V\)</span> is the number of nodes.</p>
<p>We can calculate the density of our graph:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>nx.density(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="weights" class="level3">
<h3 class="anchored" data-anchor-id="weights">2.3 Weights</h3>
<p>Often times, you may end up working with <em>weighted</em> graphs: for instance, these weights could correspond to popularity of roads in road networks, or the number of artifacts in common between sites.</p>
<p>We’ll standardize our weights to be between 1 and 2 (as otherwise the results are messy). We’ll do this using a for-loop, like we did with the degrees.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>G_weights <span class="op">=</span> nx.DiGraph() <span class="co">#creating a new graph object called G_weights</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">5</span>), (<span class="dv">3</span>,<span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">6</span>), (<span class="dv">6</span>, <span class="dv">1</span>), (<span class="dv">6</span>, <span class="dv">3</span>), (<span class="dv">6</span>,<span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">3</span>), (<span class="dv">5</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">5</span>)]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">50</span>, <span class="dv">75</span>, <span class="dv">50</span>, <span class="dv">60</span>, <span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">75</span>, <span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">100</span>] <span class="co">#add list of weights</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>G_weights.add_edges_from(edges) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>G_weights.add_nodes_from(nodes) </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>adjusted_weights <span class="op">=</span> []</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> weight <span class="kw">in</span> weights:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    adjusted_weight <span class="op">=</span> <span class="dv">1</span><span class="op">+</span> (<span class="bu">max</span>(weights)<span class="op">-</span>weight)<span class="op">/</span>(<span class="bu">max</span>(weights)<span class="op">-</span><span class="bu">min</span>(weights)) <span class="co">#standardizes weights to be between 1 and 2</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    adjusted_weights.append(adjusted_weight)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> nx.spring_layout(G, seed<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(adjusted_weights)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>nx.draw(G_weights, pos <span class="op">=</span> position, width <span class="op">=</span> adjusted_weights, with_labels <span class="op">=</span> <span class="va">True</span>) </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># width argument take in a list or array of numbers corresponding to weights</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is great, but the results aren’t very clear. Let’s add a color gradient to the edges to represent different weights.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(<span class="bu">min</span>(weights), <span class="bu">max</span>(weights), clip<span class="op">=</span><span class="va">False</span>) </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#`plot.normalizes` normalizes the weights such that they are evenly distributed across the gradient spectrum</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>edge_colors <span class="op">=</span> plt.cm.Greys(norm(weights)) </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># norm(weights) normalizes the weights </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot.cm.greys() assigns the weights to color values</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># edge_colors is a multidimensional array of RGBA color values corresponding to each edge</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots() <span class="co">#explicitly specifying figure and axes in order to create a color bar</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>nx.draw(G_weights, pos<span class="op">=</span>position, edge_color<span class="op">=</span>edge_colors, width<span class="op">=</span>adjusted_weights, with_labels<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax) </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">#ax = ax argument needed for color bar</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding color bar</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span><span class="st">"Greys"</span>, norm<span class="op">=</span>norm) <span class="co"># creates a scalarmappable object which acts </span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>                                                    <span class="co"># as a bridge between the numerical weight values and color map</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, ax<span class="op">=</span>ax) <span class="co">#plotting color bar</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="adjacency-matrices" class="level3">
<h3 class="anchored" data-anchor-id="adjacency-matrices">3. Adjacency matrices</h3>
<p>An <strong>Adjacency matrix</strong> is a method of representing graphs in matrix form. In an adjacency matrix, the rows and columns correspond to the vertices (or nodes) of the graph. The entries of the matrix indicate whether pairs of vertices are adjacent or not in the graph. Normally, a value of 1 is assigned to entries where an edge is present, and 0 is assigned to entries where an edge is not. For a weighed graph, the weight of the edge is represented as a numerical value for entries where an edge is present.</p>
<p>We can convert our simple graph to an adjacency matrix:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>nx.to_pandas_adjacency(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we want to use our weighted graph, we can use the following code:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># len(edges) returns the total number of entries in the list of edges.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># range(len(edges)): This generates a sequence of numbers from 0 to n-1 where n is len(edges), </span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#so the for-loop will run n times with i taking each value in that range, one at a time.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(edges)):</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    edge <span class="op">=</span> edges[i] <span class="co"># retrieves the edge at position i in the list of edges</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> weights[i] <span class="co"># retrieves the weight at position i in the list of weights</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    G_weights.add_edge(edge[<span class="dv">0</span>], edge[<span class="dv">1</span>], weight<span class="op">=</span>weight) <span class="co"># adds an edge with a weight to the graph </span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>nx.to_pandas_adjacency(G_weights, nodelist<span class="op">=</span>nodes, weight<span class="op">=</span><span class="st">'weight'</span>) <span class="co">#converts to pandas adjacency matrix with the weights in place</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can visualize our matrix using the code below. Note that instead of using <code>nx.to_pandas_adjacency</code> we use <code>nx.to_numpy_array</code>: this allows us to store the matrix in the form of an array.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>adj_matrix <span class="op">=</span> nx.to_numpy_array(G_weights, nodelist<span class="op">=</span>nodes, weight<span class="op">=</span><span class="st">'weight'</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>)) <span class="co">#displays data as an image on a 2d raster; in our case, a numpy array</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(adj_matrix, cmap<span class="op">=</span><span class="st">'gray_r'</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(adj_matrix.shape[<span class="dv">0</span>]): <span class="co">#loops through each row of the matrix</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(adj_matrix.shape[<span class="dv">1</span>]): <span class="co">#for each row, loops through each column of the matrix</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        plt.text(j, i, <span class="bu">int</span>(adj_matrix[i, j]),</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                 ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>, color<span class="op">=</span><span class="st">'red'</span>, size<span class="op">=</span><span class="dv">30</span>) <span class="co">#prints the value at that position in the matrix on the graph</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Adjacency Matrix Visualization'</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Node Index'</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Node Index'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="working-with-archeological-datasets" class="level2">
<h2 class="anchored" data-anchor-id="working-with-archeological-datasets">4. Working with archeological datasets</h2>
<p>The ICRATES database of tablewares in the Roman East is a dataset of red slip tablewares between the late Hellenistic and late Roman periods in the east Mediterranean (Bes, 2015). The dataset is in fact comprised of two datasets: the first is a dataset of nodes with their respected connections, as well as weights for each edge and other information. The second dataset contains geographical coordinates for each node in the network. We will use these coordinates to add a geospatial component to our analysis, by placing each node in it’s respective geographical coordinates and adding a map overlay. We begin by demonstrating how to import and visualize the dataset in python, and then introduce various centrality and connectivity measures.</p>
<p>Importantly, the nodes in the first dataset are categorized by time period. We will initially focus on a singular time period, but will showcase how to graph multiple time frames towards the end of the notebook.</p>
<section id="importing-datasets-in-python" class="level3">
<h3 class="anchored" data-anchor-id="importing-datasets-in-python">4.1 Importing datasets in Python</h3>
<p>We can import datasets in python using pandas’ <code>read_</code> function. In our case, both network and location datasets are stored in excel files. We can thus use the <code>read_excel</code> function.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>df_edges <span class="op">=</span> pd.read_excel(<span class="st">"vistorian_network.xls"</span>) <span class="co">#loading in dataset</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>G_directed <span class="op">=</span> nx.from_pandas_edgelist(df_edges, source<span class="op">=</span><span class="st">"SOURCE_LOCATION"</span>, target<span class="op">=</span><span class="st">"TARGET_LOCATION"</span>, create_using<span class="op">=</span>nx.DiGraph()) <span class="co">#creating a graph object</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_pandas_edgelist(df_edges, source<span class="op">=</span><span class="st">"SOURCE_LOCATION"</span>, target<span class="op">=</span><span class="st">"TARGET_LOCATION"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="adding-a-geospacial-component-to-our-graph" class="level3">
<h3 class="anchored" data-anchor-id="adding-a-geospacial-component-to-our-graph">4.2 Adding a geospacial component to our graph</h3>
<p>We could just plot this network right away, but this wouldn’t convey good information, as the nodes in our dataset represent real places. Instead, let’s bind each node to it’s respective geographical location using the <code>geopandas</code> library.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>df_pos <span class="op">=</span> pd.read_excel(<span class="st">"vistorian_locations.xls"</span>, index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a> <span class="co"># loading in coordinates of nodes; index_col specifies that the first column (with index 0) in the Excel sheet should be used as the row labels for the DataFrame</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>) </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a> <span class="co"># creates a geodataframe, a special dataframe from the geopandas library for storing geographic datapoints.</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># crs='EPSG:4326' argument defines the Coordinate Reference System for the geometric data: in our case, the location dataset uses the WGS84 coordinate system</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>) <span class="co">#reprojecting to web mercator for the world map overlay to accurately show up on our graph</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="co">#returns a GeoDataframe of all the nodes and their respective positions</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>gdf_pos.loc[<span class="st">'Abdera'</span>] </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"># the loc accessor in pandas (and by extension, GeoPandas, which extends pandas) is used to access a group of rows and columns by labels. This will be useful for our next step.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great! we now have a GeoDataFrame of each node in our graph, with their respective position. However, networkX’s requires a dictionary of node-location pairs for properly mapping each node. Let’s create a new dictionary using the dataframe above.</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> {} <span class="co">#empty dictionary which will contain the positions of each node</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> location <span class="kw">in</span> gdf_pos.index: <span class="co"># iterates over each index in the gdf_pos GeoDataFrame. The index in gdf_pos is the names of all our nodes.</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos.loc[location].geometry.x  <span class="co"># For each location, this line accesses the `geometry` column to retrieve the x-coordinate (latitude).</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos.loc[location].geometry.y  <span class="co"># Same thing but for y-coordinate (longitude)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    positions[location] <span class="op">=</span> (x, y)  <span class="co"># Adding to the dictionary with the location as the key</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we have a dictionary containing each node, and it’s geographic position. We can now plot our graph!</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))<span class="co"># Creating subplots so that we can overlay the network and the map</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>gdf_pos.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)<span class="co"># Adding the basemap: we are using CartoDB for this</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Drawing the network edges and nodes, as usual</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G, pos<span class="op">=</span>positions, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G, pos<span class="op">=</span>positions, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">20</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can focus on a specific geographical area by specifying longitudonal and latitudonal limits and filtering the locations dataset for locations that fall within those limits. From now on, let’s focus our analysis on the area surrounding the Aegean Sea.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We create a "bonding box" which contains the outer limits of our positions.</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y] <span class="co"># Filtering the GeoDataFrame to include only points within the bounding box</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>G_sub <span class="op">=</span> G.subgraph(filtered_nodes) <span class="co"># Create a subgraph from the original graph G using only the filtered nodes</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare positions for the filtered subgraph</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the filtered subgraph</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="working-with-weighed-graphs" class="level3">
<h3 class="anchored" data-anchor-id="working-with-weighed-graphs">4.3 Working with weighed graphs</h3>
<p>If we print the df_edges dataframe, we see that it contains <code>WEIGHT</code> and <code>TYPE</code> columns, that correspond to each edge in the network. The <code>TYPE</code> category corresponds to the type of pottery linking two sites, and the <code>WEIGHT</code> cateogry corresponds to the relative importance of each edge.</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_edges)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">max</span>(df_edges[<span class="st">'WEIGHT'</span>]))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">min</span>(df_edges[<span class="st">'WEIGHT'</span>]))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_edges[<span class="st">'TYPE'</span>].unique())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that the <code>WEIGHT</code> cateory has values that range from 0 to 17, and the <code>TYPE</code> categories has two pottery types: <code>ESB</code>, <code>ESC</code>, as well as undefined pottery types (NaN). Let’s change the <em>width</em> of each edge in the network to reflect it’s weight, and the <em>color</em> of each edge to reflect it’s type.</p>
<p>This is made slightly difficult as we are working with a subgraph and the <code>TYPE</code> and <code>WIDTH</code> categories contain entries for the full graph.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>df_edges</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>G_sub_weighted <span class="op">=</span> G.subgraph(filtered_nodes)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># creating a new column called `edge_tuple` which contains tuples of the source and target locations.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We such a column for filtering the weight and type categories to only contain edges within G_sub_weighted and not G.</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>edge_tuples <span class="op">=</span> []</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, row <span class="kw">in</span> df_edges.iterrows(): <span class="co">#Iterating over the rows of df_edges using iterrows() </span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    edge_tuple <span class="op">=</span> (row[<span class="st">'SOURCE_LOCATION'</span>], row[<span class="st">'TARGET_LOCATION'</span>])  <span class="co"># Creating a tuple from the 'SOURCE_LOCATION`` and 'TARGET_LOCATION' columns</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    edge_tuples.append(edge_tuple)  <span class="co"># Appending each tuple to the list</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>df_edges[<span class="st">'edge_tuple'</span>] <span class="op">=</span> edge_tuples <span class="co">#  appending edge_tuples to df_edges </span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>subgraph_edges <span class="op">=</span> <span class="bu">list</span>(G_sub_weighted.edges()) <span class="co">#listing all the edges in the subgraph</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>filtered_edges <span class="op">=</span> df_edges[df_edges[<span class="st">'edge_tuple'</span>].isin(subgraph_edges)] <span class="co">#filtering df_edges to only contain edges in the subgraph</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>filtered_edges.reset_index(drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>) <span class="co">#the index gets all sliced up when filtering rows, this makes it normal again</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>edge_colors <span class="op">=</span> [] <span class="co">#create an empty set which contains the colors of the artifacts ESB, ESC</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">type</span> <span class="kw">in</span> filtered_edges[<span class="st">'TYPE'</span>]: </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">'ESB'</span>:</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        edge_colors.append(<span class="st">'maroon'</span>)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">'ESC'</span>:</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        edge_colors.append(<span class="st">'navy'</span>)</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        edge_colors.append(<span class="st">'plum'</span>) </span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the weights of the edges</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> filtered_edges[<span class="st">'WEIGHT'</span>]</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>adjusted_weights <span class="op">=</span> []</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> weight <span class="kw">in</span> weights:</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    adjusted_weight <span class="op">=</span> <span class="fl">0.1</span> <span class="op">+</span> ((<span class="bu">max</span>(weights)<span class="op">-</span> <span class="bu">min</span>(weights))<span class="op">/</span><span class="dv">20</span>)  </span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    adjusted_weights.append(adjusted_weight)</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot the network on the graph</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, width<span class="op">=</span>adjusted_weights, edge_color<span class="op">=</span>edge_colors, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a><span class="co">#Show our graph</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>patch_maroon <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'maroon'</span>, label<span class="op">=</span><span class="st">'ESB'</span>) </span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>patch_navy <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'navy'</span>, label<span class="op">=</span><span class="st">'ESC'</span>) </span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch_maroon, patch_navy])</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a><span class="co">#Print information about the types of edges</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(adjusted_weights)</span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(filtered_edges)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This works, but the weightings are hard to see. One alternative is to filter the subgraph by weight, and graph the different weights side-by-side:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating a function that creates a list of colors, then apply the function to each subset of edges filtered by weight</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_edge_colors(filtered_edges):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    edge_colors <span class="op">=</span> []</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">type</span> <span class="kw">in</span> filtered_edges[<span class="st">'TYPE'</span>]: </span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">'ESB'</span>:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            edge_colors.append(<span class="st">'maroon'</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">'ESC'</span>:</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>            edge_colors.append(<span class="st">'navy'</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>            edge_colors.append(<span class="st">'green'</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> edge_colors</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Filtering the edges by weight</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>filtered_edges_w1 <span class="op">=</span> filtered_edges[filtered_edges[<span class="st">'WEIGHT'</span>] <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>filtered_edges_w2 <span class="op">=</span> filtered_edges[filtered_edges[<span class="st">'WEIGHT'</span>] <span class="op">==</span> <span class="dv">2</span>]</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>filtered_edges_w3 <span class="op">=</span> filtered_edges[filtered_edges[<span class="st">'WEIGHT'</span>] <span class="op">==</span> <span class="dv">3</span>]</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co"># applying the get_edge_colors function on each subset of edges</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>edge_colors_w1 <span class="op">=</span> get_edge_colors(filtered_edges_w1)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>edge_colors_w2 <span class="op">=</span> get_edge_colors(filtered_edges_w2)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>edge_colors_w3 <span class="op">=</span> get_edge_colors(filtered_edges_w3)</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">6</span>)) <span class="co">#creating a plot; 1, 3 creates 3 subplots spaced horizontally</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph 1: weight = 1</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Weight 1'</span>) <span class="co">#axes[n] specifies which plot to plot the graph in: axes[0] is plot 1.</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(axes[<span class="dv">0</span>], source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">0</span>], node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">0</span>], edgelist<span class="op">=</span><span class="bu">list</span>(filtered_edges_w1[<span class="st">'edge_tuple'</span>]),</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>                       edge_color<span class="op">=</span>edge_colors_w1, alpha<span class="op">=</span><span class="fl">0.4</span>) <span class="co">#`list(filtered_edges_w1['edge_tuple'])` extracts the edge_tuple column and converts the entries into a list</span></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph 2: weight = 2</span></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Weight 2'</span>)</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(axes[<span class="dv">1</span>], source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">1</span>], node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">1</span>], edgelist<span class="op">=</span><span class="bu">list</span>(filtered_edges_w2[<span class="st">'edge_tuple'</span>]),</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>                    edge_color<span class="op">=</span>edge_colors_w2, alpha<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph 3: weight = 3</span></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'Weight 3'</span>)</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>axes[<span class="dv">2</span>], alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(axes[<span class="dv">2</span>], source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">2</span>], node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span><span class="st">"red"</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_weighted, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">2</span>], edgelist<span class="op">=</span><span class="bu">list</span>(filtered_edges_w3[<span class="st">'edge_tuple'</span>]),</span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a>                       edge_color<span class="op">=</span>edge_colors_w3, alpha<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a>patch_maroon <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'maroon'</span>, label<span class="op">=</span><span class="st">'ESB'</span>) </span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a>patch_navy <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'navy'</span>, label<span class="op">=</span><span class="st">'ESC'</span>) </span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].legend(handles<span class="op">=</span>[patch_maroon, patch_navy], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].legend(handles<span class="op">=</span>[patch_maroon, patch_navy], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].legend(handles<span class="op">=</span>[patch_maroon, patch_navy], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="measures-of-centrality" class="level2">
<h2 class="anchored" data-anchor-id="measures-of-centrality">5. Measures of Centrality</h2>
<p><strong>Centrality</strong> is defined as the set of metrics used to determine the importance or influence of a particular node within a network. It helps to identify which nodes hold strategic significance in terms of connectivity, information flow, or influence over other nodes. Various centrality metrics, such as degree, betweenness, and eigenvector centrality, provide different perspectives on the role each node plays within the network’s overall structure.</p>
<section id="network-distance-and-eccentricity" class="level3">
<h3 class="anchored" data-anchor-id="network-distance-and-eccentricity">5.1 Network Distance and Eccentricity</h3>
<p>Before talking about centrality, we first need to talk a bit about <em>distance</em>. <strong>Distance</strong>, also known as <strong>Geodesic distance</strong>, is defined as the number of edges traversed by the shortest path between two nodes.</p>
<ul>
<li>The distance between a node and itself is 0.</li>
<li>The distance between a node and a node for which no shortest path exists (such as a node that is disconnected from other nodes) is <span class="math inline">\(\infty\)</span>.</li>
<li>The distance between a node and it’s neighbor is 1.</li>
</ul>
<p>A node’s <strong>eccentricity</strong> is the maximum distance from said node to all other nodes in the graph. For instance, in the following network, the eccentricity of node <span class="math inline">\(A\)</span> is 2, but the eccentricity of node <span class="math inline">\(B\)</span> is 1.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> (<span class="st">"A"</span>,<span class="st">"B"</span>, <span class="st">"C"</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="st">"A"</span>,<span class="st">"B"</span>), (<span class="st">"B"</span>, <span class="st">"C"</span>)]</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>G_example <span class="op">=</span> nx.Graph()</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>G_example.add_edges_from(edges)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>G_example.add_nodes_from(nodes)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>color_map <span class="op">=</span> [<span class="st">"salmon"</span>, <span class="st">"lightblue"</span>, <span class="st">"salmon"</span>]</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>red_patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'salmon'</span>, label<span class="op">=</span><span class="st">'eccentricity = 1'</span>) </span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>blue_patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'lightblue'</span>, label<span class="op">=</span><span class="st">'eccentricity = 2'</span>) </span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[blue_patch, red_patch])</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>nx.draw(G_example, node_color<span class="op">=</span>color_map, with_labels<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we color the nodes of our Aegean sea pottery network by eccentricity, we see an interesting result:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in our data to be used</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Set a bounding box on our data</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Use the bounding box on our data</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y] </span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>G_sub_eccentricity <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>eccentricities <span class="op">=</span> nx.eccentricity(G_sub_eccentricity) <span class="co">#calculating eccentricities</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>eccentricities_array <span class="op">=</span> np.array(<span class="bu">list</span>(eccentricities.values()))</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Set a colour map for different values of eccentricity in our network</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>color_map <span class="op">=</span> []</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> eccentricity <span class="kw">in</span> eccentricities_array:</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> eccentricity <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"palegreen"</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> eccentricity <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"slateblue"</span>)</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> eccenticity <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"orange"</span>)</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"grey"</span>)</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter oyur graph</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our graph with different colours for eccentricity</span></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_eccentricity, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_eccentricity, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'slateblue'</span>, label<span class="op">=</span><span class="st">'eccentricity = 2'</span>) </span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch])</span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a><span class="co">#show the graph</span></span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>All nodes are at most 2 edges away from every other other node!</p>
</section>
<section id="degree-centrality" class="level3">
<h3 class="anchored" data-anchor-id="degree-centrality">5.2 Degree Centrality</h3>
<p>Degree centrality is simple: Recall that the <strong>degree</strong> of a node is the number of nodes directly connected to it. In degree centrality, the more adjacent nodes, the more important the network is considered to be. Degree centrality is used primarily in social networks, where nodes with higher degrees are commonly major channels of information. A high degree means a node has many direct ties with other nodes, and has better access to resources within the network.</p>
<p>Note that the networkX <code>nx.degree_centrality()</code> function normalizes each node’s degree by dividing by the maximum possible degree in the network. Therefore for graphs without self-loops (such as the one we are working with) the degree centrality is always <span class="math inline">\(\leq 1\)</span>. For educational purposes, we un-normalize the degree values, but this is not common practice.</p>
<p>We can calculate the degree centrality of all our nodes in our network:</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in our dataset</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Set a bounding box to limit the scope of the graph</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter our graph using the bounding box </span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y] </span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>G_sub <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">#Find the centrality values </span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.degree_centrality(G_sub)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>centrality_values <span class="op">=</span> np.array(<span class="bu">list</span>(centrality.values()))</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(centrality_values)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>original_degrees <span class="op">=</span> centrality_values <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="co">#Colour our map based on the degree centrality </span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>color_map<span class="op">=</span>[]</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> original_degrees:</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(original_degrees):</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"indianred"</span>)</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>        normalized_value <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(original_degrees)  <span class="co"># Normalize the degree to the range [0, 1]</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>        color_map.append(plt.cm.winter(normalized_value))</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>cmap <span class="op">=</span> plt.cm.winter</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter our graph </span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>edges<span class="op">=</span> nx.draw_networkx_edges(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> nx.draw_networkx_nodes(G_sub, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map, cmap<span class="op">=</span>cmap, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding the colorbar using the inset_axes function</span></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(ax,</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>                   width<span class="op">=</span><span class="st">"5%"</span>, </span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="st">"30%"</span>,  </span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>                   loc<span class="op">=</span><span class="st">'lower left'</span>, </span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>ax.transAxes, </span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating colorbar</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(original_degrees), vmax<span class="op">=</span><span class="bu">max</span>(original_degrees))</span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm)</span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a>sm.set_array(original_degrees)</span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="st">'maximum degree (degree = 36)'</span>) </span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">3</span>))</span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a><span class="co">#Print some information about our graph</span></span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"minimum degree:"</span>, <span class="bu">min</span>(original_degrees))</span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"maximum degree:"</span>, <span class="bu">max</span>(original_degrees))</span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"difference:"</span>, <span class="bu">max</span>(original_degrees)<span class="op">-</span><span class="bu">min</span>(original_degrees))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="closeness-centrality" class="level3">
<h3 class="anchored" data-anchor-id="closeness-centrality">5.3 Closeness Centrality</h3>
<p><strong>Closeness centrality</strong> is a measure of how close a node is to all other nodes in the network. It can be computed as the “sum of the geodesic distances of a node to all other nodes in the network”. A node is <em>important</em> if it is <em>close to all other nodes in the network</em>. One flaw of closeness centrality is that while it is a useful indicator of node importance in small networks, it produces little variation in large networks with many edges. This is particularly evident in our example network:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Import a library so the code works</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1.inset_locator <span class="im">import</span> inset_axes</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in our data</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Bounding Box</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter our graph using bounding box</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y]</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>G_sub <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Find centrality </span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.closeness_centrality(G_sub)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>centrality_values <span class="op">=</span> np.array(<span class="bu">list</span>(centrality.values()))</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a><span class="co">#Set a colour for different values of centrality </span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>color_map<span class="op">=</span>[]</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> centrality_values:</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(centrality_values):</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"indianred"</span>)</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>        normalized_value <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(centrality_values)</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>        color_map.append(plt.cm.winter(normalized_value))</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>cmap <span class="op">=</span> plt.cm.winter</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our edges</span></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>edges<span class="op">=</span> nx.draw_networkx_edges(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> nx.draw_networkx_nodes(G_sub, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map, cmap<span class="op">=</span>cmap, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(ax,</span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a>                   width<span class="op">=</span><span class="st">"5%"</span>, </span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="st">"30%"</span>, </span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a>                   loc<span class="op">=</span><span class="st">'lower left'</span>,</span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>ax.transAxes, </span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(original_degrees), vmax<span class="op">=</span><span class="bu">max</span>(original_degrees))</span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm)</span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a>sm.set_array(original_degrees)</span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="st">'maximum closeness (closeness = 39.093)'</span>) </span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">3</span>))</span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb33-66"><a href="#cb33-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-67"><a href="#cb33-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-68"><a href="#cb33-68" aria-hidden="true" tabindex="-1"></a><span class="co">#Print information about our graph</span></span>
<span id="cb33-69"><a href="#cb33-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"minumim closeness:"</span>, <span class="bu">min</span>(original_degrees))</span>
<span id="cb33-70"><a href="#cb33-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"maximum closeness:"</span>, <span class="bu">max</span>(original_degrees))</span>
<span id="cb33-71"><a href="#cb33-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"difference:"</span>, <span class="bu">max</span>(original_degrees)<span class="op">-</span><span class="bu">min</span>(original_degrees))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="betweenness-centrality" class="level3">
<h3 class="anchored" data-anchor-id="betweenness-centrality">5.4 Betweenness Centrality</h3>
<p><strong>Betweenness Centrality</strong> is a measure of the importance of a node based on how well it serves as a <strong>bridge</strong> between nodes in a network. The mathematical representation of the betweeness centrality of a node is the number of times each node has to pass through that node to reach every other node in a network. Nodes with high betweenness thus serve as “bridges” within a network.</p>
<p>The Betweenness centrality of a given node <span class="math inline">\(i\)</span> is calculated as: <span class="math inline">\(b(i)=\sum_{j,k}\frac{g_{jik}}{g_{jk}}\)</span>, where <span class="math inline">\(g_{jik}\)</span> is the number of paths from node <span class="math inline">\(j\)</span> to node <span class="math inline">\(k\)</span> passing through node <span class="math inline">\(i\)</span>, and <span class="math inline">\(g_{jk}\)</span> is the number of paths from node <span class="math inline">\(g\)</span> to node <span class="math inline">\(j\)</span> (including paths passing through node <span class="math inline">\(i\)</span>).</p>
<p>Note that, for undirected graphs, two adjacent nodes can only have one path between them (ie, between two adjacent nodes <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, if <span class="math inline">\(A\rightarrow B\)</span> is a path, then <span class="math inline">\(B \rightarrow A\)</span> is not).</p>
<p>Consider the graph below:</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Define our network</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>G_betweenness_example <span class="op">=</span> nx.Graph()</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>edges_list <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">6</span>)]</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>G_betweenness_example.add_edges_from(edges_list)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_betweenness_example, seed<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our graph</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>nx.draw(G_betweenness_example,pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color<span class="op">=</span><span class="st">"bisque"</span>, node_size<span class="op">=</span><span class="dv">800</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Node <span class="math inline">\(4\)</span> serves as a <em>bridge</em> between nodes 5 and 6 to the rest of the nodes in the network. For a path to be drawn between nodes 6 or 5 to nodes 0,1,2,3, the path <em>must</em> go through node 4. Let’s calculate the betweenness centrality of this network, and label nodes by centrality:</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>centrality</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Define our network</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>G_betweenness_example <span class="op">=</span> nx.Graph()</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>edges_list <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">6</span>)]</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>G_betweenness_example.add_edges_from(edges_list)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_betweenness_example, seed<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Find the centrality values for our nodes</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.betweenness_centrality(G_betweenness_example, normalized<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>centrality_values <span class="op">=</span> np.array(<span class="bu">list</span>(centrality.values()))</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>cmap<span class="op">=</span><span class="st">"BuPu"</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Put labels on our network</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> {}</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_betweenness_example.nodes():</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    labels[node] <span class="op">=</span> centrality_values[node]</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our graph using `nx.draw`</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>nx.draw(G_betweenness_example,pos<span class="op">=</span>pos, node_color<span class="op">=</span>centrality_values, edgecolors<span class="op">=</span><span class="st">"black"</span>, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_labels(G_betweenness_example, pos, labels<span class="op">=</span>labels, font_color<span class="op">=</span><span class="st">"orangered"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that node 4 does indeed have the highest betweenness centrality. The values of 0 for nodes 0, 1, 2, 3 and 6 indicate that each node can reach every other node without passing through those nodes. The value of 5.0 for node 5 indicates that five nodes <em>must</em> pass through node 5 in order to reach another node. In other words, <span class="math inline">\(\frac{g_{jik}}{g_{jk}}=1\)</span> for 5 pairs of nodes in the network.</p>
<p>Coloring the nodes in our archeology dataset by betweenness centrality, we get:</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in our data</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1.inset_locator <span class="im">import</span> inset_axes</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Bounding box</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter graph using bounding box</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y] </span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>G_sub <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co">#Find centrality values and place them into an array.</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.betweenness_centrality(G_sub)</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>centrality_values <span class="op">=</span> np.array(<span class="bu">list</span>(centrality.values()))</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(centrality_values)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>original_degrees <span class="op">=</span> centrality_values <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a><span class="co">#Colour our values based on centrality</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>color_map<span class="op">=</span>[]</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> original_degrees:</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(original_degrees):</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"indianred"</span>)</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>        normalized_value <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(original_degrees) </span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>        color_map.append(plt.cm.winter(normalized_value))</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>cmap <span class="op">=</span> plt.cm.winter</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter our new network</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Create our edges and nodes</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>edges<span class="op">=</span> nx.draw_networkx_edges(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> nx.draw_networkx_nodes(G_sub, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map, cmap<span class="op">=</span>cmap, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(ax,</span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>                   width<span class="op">=</span><span class="st">"5%"</span>, </span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="st">"30%"</span>,  </span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>                   loc<span class="op">=</span><span class="st">'lower left'</span>, </span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>ax.transAxes,  </span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(original_degrees), vmax<span class="op">=</span><span class="bu">max</span>(original_degrees))</span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm)</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>sm.set_array(original_degrees)</span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot our graph</span></span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="st">'maximum betweenness (betweenness = 2.621)'</span>) </span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">3</span>))</span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="eigenvector-centrality" class="level3">
<h3 class="anchored" data-anchor-id="eigenvector-centrality">5.5 Eigenvector centrality</h3>
<p><strong>Eigenvector centrality</strong> is a measure of the influence of a node in a network by considering not just how many connections it has (as we did with degree centrality), but also the importance of those connections: A node with high eigenvector centrality is connected to many nodes that themselves have high centrality, making it more influential in spreading information or resources. Unlike simpler measures like degree centrality, which only counts connections, eigenvector centrality looks at the overall structure of the network. It helps identify key players in a network who might not have the most connections but are well-connected to other important nodes.</p>
<p>The term “eigenvector” in comes from linear algebra: an eigenvector is a special kind of vector taken from a network’s adjacency matrix. Each element in this eigenvector represents a node’s centrality in the network.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in data</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1.inset_locator <span class="im">import</span> inset_axes</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Bounding Box</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter using bounding box</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y]</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>G_sub <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co">#Find the eigenvector centrality in our graph</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.eigenvector_centrality(G_sub)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>centrality_values <span class="op">=</span> np.array(<span class="bu">list</span>(centrality.values()))</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Colour our nodes</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>color_map<span class="op">=</span>[]</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> centrality_values:</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(centrality_values):</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"indianred"</span>)</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>        normalized_value <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(centrality_values) </span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>        color_map.append(plt.cm.winter(normalized_value))</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>cmap <span class="op">=</span> plt.cm.winter</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="co">#Filter the graph</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {}</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index:</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.x</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> gdf_pos_filtered.loc[loc].geometry.y</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>    positions_filtered[loc] <span class="op">=</span> (x, y)</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our edges and nodes</span></span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>edges<span class="op">=</span> nx.draw_networkx_edges(G_sub, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> nx.draw_networkx_nodes(G_sub, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map, cmap<span class="op">=</span>cmap, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(ax,</span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>                   width<span class="op">=</span><span class="st">"5%"</span>,  </span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="st">"30%"</span>,  </span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>                   loc<span class="op">=</span><span class="st">'lower left'</span>, </span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>),  </span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>ax.transAxes, </span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(original_degrees), vmax<span class="op">=</span><span class="bu">max</span>(original_degrees))</span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm)</span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>sm.set_array(original_degrees)</span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot our graph </span></span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="st">'maximum betweenness (betweenness = 2.621)'</span>) </span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">3</span>))</span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="directed-graphs-and-putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="directed-graphs-and-putting-it-all-together">5.6 Directed graphs and Putting it all together</h3>
<p>Lastly, let’s clean up our centrality graphs by putting them together into one graph. We’ll also use a directed version of our graph, to see how that changes the results.</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Bring in our data</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>df_edges <span class="op">=</span> pd.read_excel(<span class="st">"vistorian_network.xls"</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>df_pos <span class="op">=</span> pd.read_excel(<span class="st">"vistorian_locations.xls"</span>, index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Define the graph</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>G_directed <span class="op">=</span> nx.from_pandas_edgelist(df_edges, source<span class="op">=</span><span class="st">"SOURCE_LOCATION"</span>, target<span class="op">=</span><span class="st">"TARGET_LOCATION"</span>, create_using<span class="op">=</span>nx.DiGraph())</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gpd.GeoDataFrame(df_pos, geometry<span class="op">=</span>gpd.points_from_xy(df_pos[<span class="st">'LONGITUDE'</span>], df_pos[<span class="st">'LATITUDE'</span>]), crs<span class="op">=</span><span class="st">'EPSG:4326'</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>gdf_pos <span class="op">=</span> gdf_pos.to_crs(<span class="st">'EPSG:3857'</span>)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a bounding box and filter the graph using it</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>min_x, min_y <span class="op">=</span> <span class="dv">1858948</span>, <span class="dv">4055442</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>max_x, max_y <span class="op">=</span> <span class="dv">3336323</span>, <span class="dv">5175704</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered <span class="op">=</span> gdf_pos.cx[min_x:max_x, min_y:max_y]</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>filtered_nodes <span class="op">=</span> gdf_pos_filtered.index.tolist()</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot the now directed points</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>G_filtered <span class="op">=</span> G_directed.subgraph(filtered_nodes)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>positions_filtered <span class="op">=</span> {loc: (gdf_pos_filtered.loc[loc].geometry.x, gdf_pos_filtered.loc[loc].geometry.y) <span class="cf">for</span> loc <span class="kw">in</span> gdf_pos_filtered.index}</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>fig.set_facecolor(<span class="st">'lightblue'</span>)</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axes.flatten():</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a><span class="co">#The codes below are from the above sections (more notes can be found there on what each code block does)</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting Degree Centrality</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>degree_centrality <span class="op">=</span> nx.degree_centrality(G_filtered)</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>degree_values <span class="op">=</span> np.array(<span class="bu">list</span>(degree_centrality.values()))</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(degree_values)</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>original_degrees <span class="op">=</span> degree_values <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>color_map<span class="op">=</span>[]</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> original_degrees:</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(original_degrees):</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>        color_map.append(<span class="st">"indianred"</span>)</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>        normalized_degree <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(original_degrees)  </span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>        color_map.append(plt.cm.winter(normalized_degree))</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_filtered, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_filtered, </span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>                       pos<span class="op">=</span>positions_filtered, </span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>                       node_color<span class="op">=</span>color_map, </span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>                       cmap<span class="op">=</span>plt.cm.winter, </span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>                       ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>], </span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>                       node_size<span class="op">=</span><span class="dv">60</span>, </span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>                       edgecolors<span class="op">=</span><span class="st">"black"</span>, </span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">"Degree Centrality"</span>)</span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Add colorbar for Degree Centrality</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(axes[<span class="dv">0</span>, <span class="dv">0</span>], width<span class="op">=</span><span class="st">"5%"</span>, height<span class="op">=</span><span class="st">"30%"</span>, loc<span class="op">=</span><span class="st">'lower left'</span>, </span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>].transAxes, </span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>plt.cm.winter, norm<span class="op">=</span>plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(original_degrees), vmax<span class="op">=</span><span class="bu">max</span>(original_degrees )))</span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a>sm.set_array(original_degrees)</span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="ss">f'max degree (</span><span class="sc">{</span><span class="bu">max</span>(original_degrees)<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Closeness Centrality</span></span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a>closeness_centrality <span class="op">=</span> nx.closeness_centrality(G_filtered)</span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a>closeness_values <span class="op">=</span> np.array(<span class="bu">list</span>(closeness_centrality.values()))</span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a>color_map_closeness<span class="op">=</span>[]</span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> closeness_values:</span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(closeness_values):</span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a>        color_map_closeness.append(<span class="st">"indianred"</span>)</span>
<span id="cb39-74"><a href="#cb39-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-75"><a href="#cb39-75" aria-hidden="true" tabindex="-1"></a>        normalized_degree_closeness <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(closeness_values) </span>
<span id="cb39-76"><a href="#cb39-76" aria-hidden="true" tabindex="-1"></a>        color_map_closeness.append(plt.cm.winter(normalized_degree_closeness))</span>
<span id="cb39-77"><a href="#cb39-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-78"><a href="#cb39-78" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_filtered, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-79"><a href="#cb39-79" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_filtered, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map_closeness, cmap<span class="op">=</span>plt.cm.winter, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>], node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-80"><a href="#cb39-80" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">"Closeness Centrality"</span>)</span>
<span id="cb39-81"><a href="#cb39-81" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb39-82"><a href="#cb39-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-83"><a href="#cb39-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Add colorbar for Closeness Centrality</span></span>
<span id="cb39-84"><a href="#cb39-84" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(axes[<span class="dv">1</span>, <span class="dv">0</span>], width<span class="op">=</span><span class="st">"5%"</span>, height<span class="op">=</span><span class="st">"30%"</span>, loc<span class="op">=</span><span class="st">'lower left'</span>, </span>
<span id="cb39-85"><a href="#cb39-85" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb39-86"><a href="#cb39-86" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>].transAxes, </span>
<span id="cb39-87"><a href="#cb39-87" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-88"><a href="#cb39-88" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>plt.cm.winter, norm<span class="op">=</span>plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(closeness_values), vmax<span class="op">=</span><span class="bu">max</span>(closeness_values)))</span>
<span id="cb39-89"><a href="#cb39-89" aria-hidden="true" tabindex="-1"></a>sm.set_array(closeness_values)</span>
<span id="cb39-90"><a href="#cb39-90" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb39-91"><a href="#cb39-91" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="ss">f'max closeness (</span><span class="sc">{</span><span class="bu">max</span>(closeness_values)<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb39-92"><a href="#cb39-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb39-93"><a href="#cb39-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-94"><a href="#cb39-94" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Betweenness Centrality</span></span>
<span id="cb39-95"><a href="#cb39-95" aria-hidden="true" tabindex="-1"></a>betweenness_centrality <span class="op">=</span> nx.betweenness_centrality(G_filtered)</span>
<span id="cb39-96"><a href="#cb39-96" aria-hidden="true" tabindex="-1"></a>betweenness_values <span class="op">=</span> np.array(<span class="bu">list</span>(betweenness_centrality.values()))</span>
<span id="cb39-97"><a href="#cb39-97" aria-hidden="true" tabindex="-1"></a>color_map_betweenness<span class="op">=</span>[]</span>
<span id="cb39-98"><a href="#cb39-98" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> betweenness_values:</span>
<span id="cb39-99"><a href="#cb39-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(betweenness_values):</span>
<span id="cb39-100"><a href="#cb39-100" aria-hidden="true" tabindex="-1"></a>        color_map_betweenness.append(<span class="st">"indianred"</span>)</span>
<span id="cb39-101"><a href="#cb39-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-102"><a href="#cb39-102" aria-hidden="true" tabindex="-1"></a>        normalized_degree_betweenness <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(betweenness_values)  <span class="co"># Normalize the degree to the range [0, 1]</span></span>
<span id="cb39-103"><a href="#cb39-103" aria-hidden="true" tabindex="-1"></a>        color_map_betweenness.append(plt.cm.winter(normalized_degree_betweenness))</span>
<span id="cb39-104"><a href="#cb39-104" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_filtered, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-105"><a href="#cb39-105" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_filtered, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map_betweenness, cmap<span class="op">=</span>plt.cm.winter, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>], node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-106"><a href="#cb39-106" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">"Betweenness Centrality"</span>)</span>
<span id="cb39-107"><a href="#cb39-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb39-108"><a href="#cb39-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-109"><a href="#cb39-109" aria-hidden="true" tabindex="-1"></a><span class="co"># Add colorbar for Betweenness Centrality</span></span>
<span id="cb39-110"><a href="#cb39-110" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(axes[<span class="dv">0</span>, <span class="dv">1</span>], width<span class="op">=</span><span class="st">"5%"</span>, height<span class="op">=</span><span class="st">"30%"</span>, loc<span class="op">=</span><span class="st">'lower left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), bbox_transform<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>].transAxes, borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-111"><a href="#cb39-111" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>plt.cm.winter, norm<span class="op">=</span>plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(betweenness_values), vmax<span class="op">=</span><span class="bu">max</span>(betweenness_values)))</span>
<span id="cb39-112"><a href="#cb39-112" aria-hidden="true" tabindex="-1"></a>sm.set_array(betweenness_values)</span>
<span id="cb39-113"><a href="#cb39-113" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb39-114"><a href="#cb39-114" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="ss">f'max betweenness (</span><span class="sc">{</span><span class="bu">max</span>(betweenness_values)<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb39-115"><a href="#cb39-115" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb39-116"><a href="#cb39-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-117"><a href="#cb39-117" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Eigenvector Centrality</span></span>
<span id="cb39-118"><a href="#cb39-118" aria-hidden="true" tabindex="-1"></a>eigenvector_centrality <span class="op">=</span> nx.eigenvector_centrality(G_filtered, max_iter<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb39-119"><a href="#cb39-119" aria-hidden="true" tabindex="-1"></a>eigenvector_values <span class="op">=</span> np.array(<span class="bu">list</span>(eigenvector_centrality.values()))</span>
<span id="cb39-120"><a href="#cb39-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-121"><a href="#cb39-121" aria-hidden="true" tabindex="-1"></a>color_map_eigenvector<span class="op">=</span>[]</span>
<span id="cb39-122"><a href="#cb39-122" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> eigenvector_values:</span>
<span id="cb39-123"><a href="#cb39-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> degree <span class="op">==</span> <span class="bu">max</span>(eigenvector_values):</span>
<span id="cb39-124"><a href="#cb39-124" aria-hidden="true" tabindex="-1"></a>        color_map_eigenvector.append(<span class="st">"indianred"</span>)</span>
<span id="cb39-125"><a href="#cb39-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-126"><a href="#cb39-126" aria-hidden="true" tabindex="-1"></a>        normalized_degree_eigenvector <span class="op">=</span> degree <span class="op">/</span> <span class="bu">max</span>(eigenvector_values)  <span class="co"># Normalize the degree to the range [0, 1]</span></span>
<span id="cb39-127"><a href="#cb39-127" aria-hidden="true" tabindex="-1"></a>        color_map_eigenvector.append(plt.cm.winter(normalized_degree_eigenvector))</span>
<span id="cb39-128"><a href="#cb39-128" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_filtered, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-129"><a href="#cb39-129" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_filtered, pos<span class="op">=</span>positions_filtered, node_color<span class="op">=</span>color_map_eigenvector, cmap<span class="op">=</span>plt.cm.winter, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">1</span>], node_size<span class="op">=</span><span class="dv">60</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-130"><a href="#cb39-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">"Eigenvector Centrality"</span>)</span>
<span id="cb39-131"><a href="#cb39-131" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb39-132"><a href="#cb39-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-133"><a href="#cb39-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Add colorbar for Eigenvector Centrality</span></span>
<span id="cb39-134"><a href="#cb39-134" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(axes[<span class="dv">1</span>, <span class="dv">1</span>], width<span class="op">=</span><span class="st">"5%"</span>, height<span class="op">=</span><span class="st">"30%"</span>, loc<span class="op">=</span><span class="st">'lower left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), bbox_transform<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">1</span>].transAxes, borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-135"><a href="#cb39-135" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span>plt.cm.winter, norm<span class="op">=</span>plt.Normalize(vmin<span class="op">=</span><span class="bu">min</span>(eigenvector_values), vmax<span class="op">=</span><span class="bu">max</span>(eigenvector_values)))</span>
<span id="cb39-136"><a href="#cb39-136" aria-hidden="true" tabindex="-1"></a>sm.set_array(eigenvector_values)</span>
<span id="cb39-137"><a href="#cb39-137" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb39-138"><a href="#cb39-138" aria-hidden="true" tabindex="-1"></a>patch <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'indianred'</span>, label<span class="op">=</span><span class="ss">f'max eigenvector centrality (</span><span class="sc">{</span><span class="bu">max</span>(eigenvector_values)<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb39-139"><a href="#cb39-139" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend(handles<span class="op">=</span>[patch], loc<span class="op">=</span><span class="st">'upper left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="group-level-analysis-finding-subgroups-within-networks" class="level2">
<h2 class="anchored" data-anchor-id="group-level-analysis-finding-subgroups-within-networks">6. Group-level analysis: finding subgroups within networks</h2>
<p><strong>Cohesive subgroups</strong> in network analysis refer to clusters of nodes within a network that are more <em>densely connected to each other than to the rest of the network</em>. These subgroups indicate areas of high interaction or strong relationships within the larger network. Identifying cohesive subgroups helps in understanding the structure and dynamics of the network, such as how information or influence flows within and between these groups. The process of finding cohesive subgroups within networks is called <strong>cohesive group analysis</strong>.</p>
<ul>
<li>A <strong>clique</strong> is a subset of nodes within a graph where every node is directly connected to every other node in the subset. This means that in a clique, all possible edges between the nodes are present, making it a maximally connected subgraph.
<ul>
<li>All nodes are that are by themselves are inherently a clique (a 1-clique)</li>
</ul></li>
<li>In undirected graphs, a <strong><span class="math inline">\(k\)</span>-core</strong> is a subgraph in which every node is connected to at least <span class="math inline">\(k\)</span> other nodes within the subgraph. The <span class="math inline">\(k\)</span>-core is obtained by iteratively removing all nodes with a degree less than <span class="math inline">\(k\)</span> until no more nodes can be removed.</li>
</ul>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Create our network</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>G_cliques_example <span class="op">=</span> nx.Graph()</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>edges_list <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">6</span>)]</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>G_cliques_example.add_edges_from(edges_list)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_cliques_example, seed<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Find our cliques and print where they are</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> nx.find_cliques(G_cliques_example)]</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cliques)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our graph      </span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>nx.draw(G_cliques_example,pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color <span class="op">=</span> <span class="st">"bisque"</span>, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that there are three cliques in this network: <span class="math inline">\((4, 0, 1, 2, 3)\)</span>, <span class="math inline">\((4, 5)\)</span>, and <span class="math inline">\((6, 5)\)</span>:</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Set the figure size (24,6) not (8,6) because we have 3 graphs to show</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">24</span>, <span class="dv">6</span>))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>fig.set_facecolor(<span class="st">'lightblue'</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Create our network</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>G_cliques_example <span class="op">=</span> nx.Graph()</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>edges_list <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">6</span>)]</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>G_cliques_example.add_edges_from(edges_list)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_cliques_example, seed<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Find our cliques and print them</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> nx.find_cliques(G_cliques_example)]</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cliques)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a><span class="co">#Colour our cliques</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>clique_1 <span class="op">=</span> [<span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"bisque"</span>, <span class="st">"bisque"</span>]</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>clique_2 <span class="op">=</span> [<span class="st">"bisque"</span>, <span class="st">"bisque"</span>, <span class="st">"bisque"</span>,  <span class="st">"bisque"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"bisque"</span>]</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>clique_3 <span class="op">=</span> [<span class="st">"bisque"</span>, <span class="st">"bisque"</span>, <span class="st">"bisque"</span>, <span class="st">"bisque"</span>,  <span class="st">"bisque"</span>, <span class="st">"mediumseagreen"</span>, <span class="st">"mediumseagreen"</span>]</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our cliques       </span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>nx.draw(G_cliques_example, ax<span class="op">=</span>axes[<span class="dv">0</span>], pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color <span class="op">=</span> clique_1, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>nx.draw(G_cliques_example, ax<span class="op">=</span>axes[<span class="dv">1</span>], pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color <span class="op">=</span> clique_2, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>nx.draw(G_cliques_example, ax<span class="op">=</span>axes[<span class="dv">2</span>], pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color <span class="op">=</span> clique_3, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Create our example graph</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>G_cliques_example <span class="op">=</span> nx.Graph()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>edges_list <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">6</span>)]</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>G_cliques_example.add_edges_from(edges_list)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G_cliques_example, seed<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Find the cliques</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> nx.find_cliques(G_cliques_example)]</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cliques)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co">#For loop</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>node_counts <span class="op">=</span> {}</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> clique <span class="kw">in</span> cliques: <span class="co">#for each clique in the list of cliques...</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> clique: <span class="co"># for each node in each clique...</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">in</span> node_counts: <span class="co">#checks whether the current node already exists as a key in the node_counts dictionary</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>            node_counts[node] <span class="op">+=</span> <span class="dv">1</span> <span class="co">#if it is in the dictionary, increase it's value by 1</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>            node_counts[node] <span class="op">=</span> <span class="dv">1</span> <span class="co">#if it isn't, dont change</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="co">#Colour our nodes</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> []</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_cliques_example.nodes():</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node_counts[node] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"lightgreen"</span>)</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> node_counts[node] <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"forestgreen"</span>)</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> node_counts[node] <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"orange"</span>)</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"red"</span>)</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our network           </span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>nx.draw(G_cliques_example,pos<span class="op">=</span>pos, with_labels<span class="op">=</span><span class="va">True</span>, edgecolors<span class="op">=</span><span class="st">"black"</span>, node_color <span class="op">=</span> colors, cmap<span class="op">=</span>cmap, node_size<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>patch_green <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'lightgreen'</span>, label<span class="op">=</span><span class="st">'node in one clique'</span>) </span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>patch_forest <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'forestgreen'</span>, label<span class="op">=</span><span class="st">'node in two cliques'</span>) </span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch_green, patch_forest])</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s repeat the same process as the example above on our archeology dataset:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>G_sub_cliques <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Set the plot size</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Find our cliques</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> nx.find_cliques(G_sub_cliques)]</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cliques)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>node_counts <span class="op">=</span> {} <span class="co">#empty dictionary of key-value pairs where keys are nodes and values are the frequency that they show up in a clique</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_sub_cliques.nodes():</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    node_counts[node] <span class="op">=</span> <span class="dv">0</span> <span class="co"># makes dictionary values start at 0 </span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> clique <span class="kw">in</span> cliques: <span class="co">#for each clique in the list of cliques...</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> clique: <span class="co"># for each node in each clique...</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>        node_counts[node] <span class="op">+=</span> <span class="dv">1</span> <span class="co">#if it is in the dictionary, increase it's value by 1</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a><span class="co">#Set the colours  for different cliques</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> []</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>max_values <span class="op">=</span> <span class="bu">max</span>(node_counts.values()) </span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>min_values <span class="op">=</span> <span class="bu">min</span>(node_counts.values())</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_sub_cliques.nodes():</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> node_counts.get(node, <span class="dv">0</span>)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">==</span> max_values:</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"salmon"</span>)</span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> count <span class="op">==</span> min_values:</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>        colors.append(<span class="st">"forestgreen"</span>)</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>        normalized_value <span class="op">=</span> count <span class="op">/</span> max_values</span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>        colors.append(plt.cm.PuBu(normalized_value))</span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our network</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_cliques, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_cliques, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span>colors, edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a><span class="co">#Make a legend in the corner of the graph with labels</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>patch_forestgreen <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'forestgreen'</span>, label<span class="op">=</span><span class="ss">f"Minimum number of cliques: </span><span class="sc">{</span>min_values<span class="sc">}</span><span class="ss">"</span>) </span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>patch_salmon <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'salmon'</span>, label<span class="op">=</span><span class="ss">f"Maximum number of cliques: </span><span class="sc">{</span>max_values<span class="sc">}</span><span class="ss">"</span>) </span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch_salmon, patch_forestgreen])</span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>axins <span class="op">=</span> inset_axes(ax,</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a>                   width<span class="op">=</span><span class="st">"5%"</span>,  </span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>                   height<span class="op">=</span><span class="st">"30%"</span>,  </span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>                   loc<span class="op">=</span><span class="st">'lower left'</span>,  </span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>                   bbox_to_anchor<span class="op">=</span>(<span class="fl">0.03</span>, <span class="fl">0.03</span>, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>                   bbox_transform<span class="op">=</span>ax.transAxes,  </span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a>                   borderpad<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a>node_counts_values <span class="op">=</span> np.array(<span class="bu">list</span>(node_counts.values()))</span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> plt.Normalize(vmin<span class="op">=</span>min_values, vmax<span class="op">=</span>max_values)</span>
<span id="cb43-53"><a href="#cb43-53" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> plt.cm.ScalarMappable(cmap<span class="op">=</span><span class="st">"PuBu"</span>, norm<span class="op">=</span>norm)</span>
<span id="cb43-54"><a href="#cb43-54" aria-hidden="true" tabindex="-1"></a>sm.set_array(node_counts_values)</span>
<span id="cb43-55"><a href="#cb43-55" aria-hidden="true" tabindex="-1"></a>plt.colorbar(sm, cax<span class="op">=</span>axins, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb43-56"><a href="#cb43-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-57"><a href="#cb43-57" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot our graph</span></span>
<span id="cb43-58"><a href="#cb43-58" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="network-level-analysis-clusters-and-clustering-coefficients" class="level2">
<h2 class="anchored" data-anchor-id="network-level-analysis-clusters-and-clustering-coefficients">7. Network-level analysis: Clusters and clustering coefficients</h2>
<p>A <strong>cluster</strong> (also known as a community) is a set of nodes in a graph that are densely connected to each other but sparsely connected to nodes in other clusters. For example, in a social network, a cluster might represent a group of people who frequently interact with each other but have fewer interactions with people outside the group. <strong>Community detection</strong> is the process of finding such communities within nodes.</p>
<p>Before diving into community detection, we first need to understand modularity. <strong>Modulaity</strong> is a numerical measure for the community structure of a graph: it compares the density of edges within the communities of a network to the density of edges between communities. Mathematically, modularity compares the observed density of edges within a community to the expected density of edges if the connections were random. A positive modularity value suggests a strong community structure, while values closer to zero or negative indicate that the divisions are no better than random.</p>
<section id="louvain-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="louvain-algorithm">7.1 Louvain Algorithm</h3>
<p>The Louvain algorithm is a community detection method in networks that aims to optimize modularity. By optimizing modularity, the Louvain algorithm effectively uncovers natural divisions in the network where connections are dense within clusters and sparse between them, thus identifying meaningful community structures.</p>
<p>First, each node is assigned to its own community, and nodes are then iteratively moved to neighboring communities if it increases the modularity. In the second phase, the algorithm creates a new network where each community from the first phase is treated as a single node, and the process is repeated. This hierarchical approach continues until no further modularity improvements can be made, resulting in a final set of communities that maximize modularity.</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>G_sub_louvain <span class="op">=</span> G.subgraph(filtered_nodes) </span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Set our figure size</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">9</span>))</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>gdf_pos_filtered.plot(ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>ctx.add_basemap(ax, source<span class="op">=</span>ctx.providers.CartoDB.Positron)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>partition <span class="op">=</span> community_louvain.best_partition(G_sub_louvain) <span class="co">#applying louvain</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Colour map of possible colors with values associated with it</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>color_map <span class="op">=</span> {</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: <span class="st">"coral"</span>,</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"cornflowerblue"</span>,</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"limegreen"</span>,</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"crimson"</span>,</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"purple"</span>}</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Set node colors</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>node_colors <span class="op">=</span> []</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G_sub_louvain.nodes():</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    cluster_id <span class="op">=</span> partition[node]  <span class="co"># Get the cluster ID for the node</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> color_map[cluster_id]  <span class="co"># Get the corresponding color from the color_map</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    node_colors.append(color)</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a><span class="co">#Draw our network</span></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G_sub_louvain, pos<span class="op">=</span>positions_filtered, ax<span class="op">=</span>ax, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G_sub_louvain, pos<span class="op">=</span>positions_filtered, </span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>                       ax<span class="op">=</span>ax, node_size<span class="op">=</span><span class="dv">60</span>, node_color<span class="op">=</span>node_colors,edgecolors<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(partition)</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a><span class="co">#Make a legend in the corner with color values and show our graph </span></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>patch_coral <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'coral'</span>, label<span class="op">=</span><span class="st">"Community 0"</span>) </span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>patch_cornflower <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'cornflowerblue'</span>, label<span class="op">=</span><span class="st">"Community 1"</span>) </span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>patch_limegreen <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'limegreen'</span>, label<span class="op">=</span><span class="st">"Community 2"</span>) </span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>patch_crimson <span class="op">=</span> mpatches.Patch(color<span class="op">=</span><span class="st">'crimson'</span>, label<span class="op">=</span><span class="st">"Community 4"</span>) </span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[patch_coral, patch_cornflower, patch_limegreen, patch_crimson])</span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>clusters <span class="op">=</span> {}</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterating through the partition dictionary</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node, cluster <span class="kw">in</span> partition.items():</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cluster <span class="kw">not</span> <span class="kw">in</span> clusters:     <span class="co"># If the cluster is not already in the dictionary, add it</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        clusters[cluster] <span class="op">=</span> []</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    clusters[cluster].append(node)    </span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"community_0:"</span>, clusters[<span class="dv">0</span>]) <span class="co">#Prints the names of nodes in each community 0,1,2 </span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"community_1:"</span>, clusters[<span class="dv">1</span>])</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"community_2:"</span>, clusters[<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="clustering-coefficients" class="level3">
<h3 class="anchored" data-anchor-id="clustering-coefficients">7.2 Clustering coefficients</h3>
<p>The last thing we’ll cover is clustering coefficients. The <strong>clustering coefficient</strong> of a graph is the measure of how closely nodes in a graph tend to cluster together. It gives an indication of the degree to which nodes in a graph tend to form clusters. Mathematically, the clustering coefficient is the fraction of a node’s neighbors (nodes connected to that node via an edge), that are also neighbors with each other.</p>
<p>There are two primary types of clustering coefficients: <em>local</em> coefficients and <em>global</em> coefficients. A <strong>local coefficient</strong> is a measure of how many of the node’s neighbors are also neighbors of each other, relative to the total number of <em>possible</em> connections between those neighbors. Mathematically, it is expressed as: <span class="math display">\[C(v)=\frac{2 \cdot\; T(v)}{k_{v}​×(k_{v}​−1)}​\]</span></p>
<p>Where v is a node in a graph, <span class="math inline">\(T(v)\)</span> is the actual number of edges between the neighbors of v, and <span class="math inline">\(k_{v}​×(k_{v}​−1)\)</span> is the maximum total number of possible connections between the neighbors of v.</p>
<p>The <strong>global coefficient</strong> is the <em>average</em> of the local coefficients of all the nodes in a graph. Both coefficients range between 0 and 1.</p>
<p>We can calculate the global and local coefficients for our network:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>clustering_coefficients <span class="op">=</span> nx.clustering(G_sub_louvain)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(clustering_coefficients)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The code above gives the clustering coefficients for every node in the graph. If we want the global coefficient, we can use:</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>average_clustering_coefficient <span class="op">=</span> nx.average_clustering(G_sub_louvain)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(average_clustering_coefficient)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our high clustering coefficient indicates that the nodes in this network tend to create tightly knit groups with a high density of connections.</p>
</section>
</section>
<section id="citations" class="level2">
<h2 class="anchored" data-anchor-id="citations">8. Citations</h2>
<p>Al-Taie, M. Z., &amp; Kadry, S. (2017). <em>Python for graph and network analysis</em>. Springer. https://doi.org/10.1007/978-3-319-53004-8</p>
<p>Bes, P. (2015). <em>Once upon a time in the east: The chronological and geographical distribution of terra sigillata and red slip ware in the Roman East</em> (Vol. 6). Archaeopress. (Roman and Late Antique Mediterranean Pottery)</p>
<p>Brughmans, T., &amp; Bach, B. (2018). <em>The Vistorian: Exploring archaeological networks</em>. https://archaeologicalnetworks.wordpress.com/resources/#vistorian</p>
<p>Brughmans, T., &amp; Peeples, M. A. (2023). <em>Network science in archaeology</em>. Cambridge University Press. https://doi.org/10.1017/9781009170659</p>
<p>Mills, B. J., Clark, J. J., Peeples, M. A., Haas, W. R., Roberts, J. M., Hill, J. B., Huntley, D. L., Borck, L., Breiger, R. L., Clauset, A., &amp; Shackley, M. S. (2013). Transformation of social networks in the late pre-Hispanic US Southwest. <em>Proceedings of the National Academy of Sciences, 110</em>(15), 5785–5790. https://doi.org/10.1073/pnas.1219966110</p>
<p>QuantEcon DataScience. (n.d.). <em>Social and economic networks</em>. https://datascience.quantecon.org/applications/networks.html</p>
<p>Sayama, H. (2024, April 30). <em>Generating random graphs</em>. In <em>Introduction to the modeling and analysis of complex systems</em>. Mathematics LibreTexts. https://math.libretexts.org/Bookshelves/Scientific_Computing_Simulations_and_Modeling/ Introduction_to_the_Modeling_and_Analysis_of_Complex_Systems_(Sayama)/15%3A_Basics_of_Networks/15.06%3A_Generating_Random_Graphs</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a>.  <a rel="license" href="https://comet.arts.ubc.ca/pages/copyright.html">See details.</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 The COMET Project and the UBC Vancouver School of Economics are located on the traditional, ancestral and unceded territory of the xʷməθkʷəy̓əm (Musqueam) and Sḵwx̱wú7mesh (Squamish) peoples.
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>